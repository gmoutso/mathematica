(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



BeginPackage["xAct`xVect`",{"xAct`xTensor`","xAct`xCore`","xAct`xPerm`"}];


IndexBelongsTo[vbundle_,a_]:=VBundleOfIndex[a]===vbundle;
IndexBelongsToQ[vbundle_]:=IndexBelongsTo[vbundle,#]&;


SameUpDown[ind1_,ind2_]:=Or[And[UpIndexQ[ind1],UpIndexQ[ind2]],And[DownIndexQ[ind1],DownIndexQ[ind2]]];
SameUpDownQ[ind1_]:=Or[And[UpIndexQ[ind1],UpIndexQ],And[DownIndexQ[ind1],DownIndexQ]];


SameBundle[ind1_,ind2_]:=VBundleOfIndex[ind1]===VBundleOfIndex[ind2];
SameBundleQ[ind1_][ind2_]:=VBundleOfIndex[ind1]===VBundleOfIndex[ind2];


(*(Attributes[#]={HoldAll})&/@{DefZero,MakeZeroRule,MakeRule};*)


MakeZeroRule[tens_[inds___]]:=MakeRule[{tens[inds],Zero[inds]}];
MakeZeroRule[tens1_,tensr__]:=MakeZeroRule[tens1]~Join~MakeZeroRule[tensr];
MakeZero[tens__]:=ReplaceAll[#,MakeZeroRule[tens]]&


ReplaceTensor[tens1_,tens2_]:=ReplaceAll[#,MakeRule[{tens1,tens2}]]&


DefZero[tens_[inds___]]:=With[
(*the input indices are rewritten as patterns*)
{indspattern=Sequence@@Replace[List[inds],{a_Symbol->a_Symbol,-a_Symbol->-a_Symbol},{1}]
,
indsbundles=VBundleOfIndex/@List[inds]
,
indsnominus=Replace[List[inds],-a_Symbol->a,{1}]
},
With[{conditions=Inner[auxSubvbundleQ[#1,auxVBundleOfIndex[#2]]&,indsbundles,indsnominus,And]},
ReleaseHold[ReplaceAll[
Hold[tens/:oper_?CovDQ[ind1_][tens[indspattern]]:=oper[ind1][tens[indspattern]]/;conditions],
{auxSubvbundleQ->SubvbundleQ,auxVBundleOfIndex->VBundleOfIndex}
]];
ReleaseHold[ReplaceAll[
Hold[tens/:oper_[ind1_][tens[indspattern]]:=Zero[inds]/;conditions],
{auxSubvbundleQ->SubvbundleQ,auxVBundleOfIndex->VBundleOfIndex}
]];(*tens/:oper_[tens[ind2patt]]:=Zero[ind2];*)
];]
DefZero[tens1_,tensr__]:={DefZero[tens1],DefZero[tensr]};


MakeNewDelta[funct_]:=Module[{},

(*Register funct*)

xTensorQ[funct]^=True;
DependenciesOfTensor[funct]^={};
PrintAs[funct]^="\[Delta]";
SlotsOfTensor[funct]^={-All,All};
MasterOf[funct]^=Symbol;
Dagger[funct]^=funct;

(*DU funct*)

funct[-a_Symbol,a_Symbol]:=DimOfVBundle@VBundleOfIndex[a];
(*we change this from the delta definition!*)
funct/:(f_Symbol/;f===Times)[expr1___,funct[-a_Symbol,b_Symbol],expr2___]:=ReplaceIndex[expr1 expr2,-b->-a]/;IsIndexOf[expr1 expr2,-b,funct]&&SubvbundleQ[VBundleOfIndex[b],VBundleOfIndex[a]];
funct/:(f_Symbol/;f===Times)[expr1___,funct[-a_Symbol,b_Symbol],expr2___]:=ReplaceIndex[expr1 expr2,a->b]/;IsIndexOf[expr1 expr2,a,funct]&&SubvbundleQ[VBundleOfIndex[a],VBundleOfIndex[b]];
funct[a_,b:{_,_Symbol}]:=Basis[a,b];
funct[a:{_,-_Symbol},b_]:=Basis[a,b];
funct[a,b:_?BasisQ[_]]:=Basis[a,b];
funct[a:-_?BasisQ[_],b_]:=Basis[a,b];
funct/:(_?FirstDerQ)[funct[-_Symbol,_Symbol]]:=0;
ParamD[__][funct[-_Symbol,_Symbol]]:=0;

(*UD funct. Use SymmetryOfIndex*)

funct[a_Symbol,-a_Symbol]:=xAct`xTensor`Private`SymmetryOfIndex[a] DimOfVBundle@VBundleOfIndex[a];
(*G: we change this from the delta definition!*)
funct/:(f_Symbol/;f===Times)[expr1___,funct[a_Symbol,-b_Symbol],expr2___]:=xAct`xTensor`Private`SymmetryOfIndex[a] ReplaceIndex[expr1 expr2,b->a]/;IsIndexOf[expr1 expr2,b,funct]&&SubvbundleQ[VBundleOfIndex[b],VBundleOfIndex[a]];
funct/:(f_Symbol/;f===Times)[expr1___,funct[a_Symbol,-b_Symbol],expr2___]:=xAct`xTensor`Private`SymmetryOfIndex[a] ReplaceIndex[expr1 expr2,-a->-b]/;IsIndexOf[expr1 expr2,-a,funct]&&SubvbundleQ[VBundleOfIndex[a],VBundleOfIndex[b]];

funct[a_,b:{_,-_Symbol}]:=xAct`xTensor`Private`SymmetryOfIndex[a] Basis[b,a];
funct[a:{_,_Symbol},b_]:=xAct`xTensor`Private`SymmetryOfIndex[b] Basis[b,a];
funct[a_,b:-_?BasisQ[_]]:=xAct`xTensor`Private`SymmetryOfIndex[a] Basis[b,a];
funct[a:_?BasisQ[_],b_]:=xAct`xTensor`Private`SymmetryOfIndex[b] Basis[b,a];
funct/:(_?FirstDerQ)[funct[_Symbol,-_Symbol]]:=0;
ParamD[__][funct[_Symbol,-_Symbol]]:=0;
(*Symmetry of funct is symmetry of metric*)
SymmetryGroupOfTensor[funct[a_,b_]]^:=With[{metric=xAct`xTensor`Private`FirstMetricOfVBundle[VBundleOfIndex[a],False]},If[metric===Null,StrongGenSet[{},GenSet[]],SymmetryGroupOfTensor[metric]]];

(*Conversion to metric if both indices are abstract and have same height*)
funct[a_Symbol,b_Symbol]:=With[{metric=xAct`xTensor`Private`FirstMetricOfVBundle[VBundleOfIndex[a],True]},If[xAct`xTensor`Private`SymmetryOfMetric[metric]=!=1,Message[funct::warning,"funct converted into non-symmetric "<>ToString[metric]]];
metric[a,b]];
funct[-a_Symbol,-b_Symbol]:=With[{metric=xAct`xTensor`Private`FirstMetricOfVBundle[VBundleOfIndex[a],True]},If[xAct`xTensor`Private`SymmetryOfMetric[metric]=!=1,Message[funct::warning,"funct converted into non-symmetric "<>ToString[metric]]];
metric[-a,-b]];
(*Protection*)
SetNumberOfArguments[funct,2];
SetAttributes[funct,{(*ReadProtected,Protected*)}];
funct]


MakeNewDelta[IdDelta]


DefVMetricCheck::notsym="not symmetric tensor used";
DefVMetricCheck::notcomp="tensor indices do not match";
DefVMetricCheck::def="metric has already been defined";


DefVMetricCheck[signdet_,metric_[-ind1_,-ind2_],odeps_,eoib_]:=Module[{vb},
(* does not assume metric exists *)
If[!AbstractIndexQ[ind1],Throw@Message[DefMetric::unknown,"abstract index",ind1]];
If[!AbstractIndexQ[ind2],Throw@Message[DefMetric::unknown,"abstract index",ind2]];
vb=VBundleOfIndex[ind1];
If[vb=!=VBundleOfIndex[ind2],Throw@Message[DefMetric::inds,ind1, ind2]];
If[MetricEndowedQ[vb],Message[DefMetric::old,MetricsOfVBundle[vb],vb]];
If[!Or[ManifoldQ[#],ParameterQ[#]],Throw@Message[DefMetric::unknown,"dependency",#]]&/@odeps;
(* ValidateSymbolInSession[metric]; *)(* not needed, checks against user-defined *)
(* signdet accepts 0, 1, or {p,q,r}*)
Which[
Abs[signdet]===1,Null,
signdet===0,Null,
MatchQ[signdet,{_Integer?NonNegative,_Integer?NonNegative,_Integer?NonNegative}],Null,
True,Throw@Message[DefMetric::invalid,signdet,"signdet of metric"]
];
(* epsilon orientation in a basis *)
Which[
Head[eoib]=!=List||Length[eoib]=!=2,Throw@Message[DefMetric::invalid,eoib,"value for option epsilonOrientationInMetric"],
!BasisQ[eoib[[1]]],Throw@Message[DefMetric::unknown,"basis",eoib[[1]]],
_,Null
];

ValidateSymbol[metric]; (* checks against system and other packages *)
If[xTensorQ[metric],
If[SymmetryGroupOfTensor[metric]=!=StrongGenSet[{1,2},GenSet[xAct`xPerm`Cycles[{1, 2}]]],Throw@Message[DefVMetricCheck::notsym]];
If[SlotsOfTensor[metric][[1]]=!=vb,Throw@Message[DefVMetricCheck::notcomp]];
If[MemberQ[$Metrics,metric],Throw@Message[DefVMetricCheck::def]]
]
]


Unprotect[DefVMetric]
Off[RuleDelayed::rhs];
Options[DefVMetric]:={
PrintAs->Identity,
OtherDependencies->{},
epsilonOrientationInBasis:>{AIndex,$epsilonSign},
Master->Null,
ProtectNewSymbol:>$ProtectNewSymbols,
DefInfo->{"",""}}
DefVMetric[signdet_,metric_[-ind1_,-ind2_],options:OptionsPattern[]]:=Catch@With[{
vbundle=VBundleOfIndex[ind1]},
Module[{covdsymbol,odeps,eoib,pns,info,frozenQ,firstQ,invertQ,LCmetric},

(* Options and checks *)
{odeps,eoib,pns,info}=OptionValue[DefVMetric,{options},{OtherDependencies,epsilonOrientationInBasis,ProtectNewSymbol,DefInfo}];

(* checks *)
DefVMetricCheck[signdet,metric[-ind1,-ind2],odeps,eoib];

firstQ=MetricsOfVBundle[vbundle]==={};
frozenQ=!firstQ;

With[{
manifold=BaseOfVBundle[vbundle],
deps=Union[{BaseOfVBundle[vbundle]},odeps],
(*these two functions add symbols to names*)
vbpmQ=xAct`xTensor`Private`VBundleIndexPMQ[vbundle],
invmetric=If[frozenQ,GiveSymbol[Inv,metric],metric]},

(* Avoid messages from options of DefMetric not accepted in DefTensor or DefCovD *)
Off[OptionValue::nodef];

(* define metric if DNE *)
If[!xTensorQ[metric],
DefTensor[metric[-ind1,-ind2],deps,Symmetric[{1,2}],
ProtectNewSymbol->False,
DefInfo:>If[info===False,False,{"symmetric fiber metric tensor",""}],
options]];

(* MakexTensions (see xTension). *)
MakexTensions[DefVMetric,"Beginning",signdet,metric[-ind1,-ind2],options];

(* Register structure *)
AppendToUnevaluated[$Metrics,metric];
MetricQ[metric]^=True;
VBundleOfMetric[metric]^=vbundle;
xUpAppendTo[MetricsOfVBundle[vbundle],metric];

(* Signature *)
If[Head[signdet]===List&&Length[signdet]===3,
SignatureOfMetric[metric]^=signdet;
SignDetOfMetric[metric]^=If[signdet[[3]]===0,(-1)^signdet[[2]],0],
SignDetOfMetric[metric]^=signdet;
];

(* Define Inverse *)
invertQ=SignDetOfMetric[metric]=!=0;
If[invertQ,
If[frozenQ,
DefTensor[invmetric[ind1,ind2],deps,Symmetric[{1,2}],
ProtectNewSymbol->False,
Master->metric,
DefInfo:>If[info===False,False,{"inverse metric tensor","Metric is frozen!"}],
TensorID->{xAct`xTensor`Private`InvMetric,metric},
PrintAs:>GiveOutputString[Inv,metric],
options],
Inv[metric]^=metric
],
Print["** DefMetric: non-invertible metric being defined! Dangerous!"]
];

(* Directional indices are not allowed in metrics. Why only for first metrics? *)
If[firstQ,
metric[Dir[expr_],b_]:=ReplaceIndex[expr,xAct`xTensor`Private`UltraindexOf[expr]->b];
metric[a_,Dir[expr_]]:=ReplaceIndex[expr,xAct`xTensor`Private`UltraindexOf[expr]->a];
];

(* Define epsilon tensor, with covariant indices. Do not protect symbol *)
DefVEpsilonOfMetric[metric,vbundle,eoib,frozenQ]

(* Self-contractions *)
MakeLinearMetric[metric,invmetric,IdDelta,vbundle,firstQ]

(* Determinant in the basis AIndex. Has to be defined after the covd and the invmetric *)
If[info===False,
Block[{$DefInfoQ=False},Determinant[metric,AIndex][]],
Determinant[metric,AIndex][]
];

MakexTensions[DefVMetric,"End",signdet,metric[-ind1,-ind2],options];

On[OptionValue::nodef];

If[pns,Protect[metric]];
]
]
];
DefVMetric[_,metric_,_,OptionsPattern[]]:=Message[DefMetric::invalid,metric,"metric"];
SetNumberOfArguments[DefVMetric,{3,Infinity}];
Protect[DefVMetric];
On[RuleDelayed::rhs];


DefVEpsilonOfMetric[metric_,vbundle_,eoib_,frozenQ_]:=Module[{dim,integerdimQ},
dim=DimOfVBundle[vbundle];
integerdimQ=IntegerQ[dim];

metric/:epsilonOrientation[metric,eoib[[1]]]=eoib[[2]];
With[{epsilonname=GiveSymbol[epsilon,metric],
inds=GetIndicesOfVBundle[vbundle,If[integerdimQ,dim,2]]},
DefTensor[epsilonname@@(ChangeIndex/@inds),DependenciesOfTensor[metric],Antisymmetric@Range@Length@inds,
PrintAs:>GiveOutputString[epsilon,metric],
ProtectNewSymbol->False,
Master->metric,
DefInfo:>{"antisymmetric tensor",""}
TensorID->{epsilon,metric}];
If[!integerdimQ,
TagSetDelayed[epsilonname,SymmetryGroupOfTensor[epsilonname[inds1__]],Antisymmetric[Range@Length@{inds1}]];
TagUnset[epsilonname,SymmetryGroupOfTensor[epsilonname]];
TagSetDelayed[epsilonname,SymmetryGroupOfTensor[epsilonname],Antisymmetric[Range@DimOfVBundle@vbundle]]
];
If[frozenQ,
epsilonname/:epsilonname[inds1__]epsilonname[inds2__]:=SignDetOfMetric[metric]ExpandGdelta[metric][inds1,inds2],
epsilonname/:epsilonname[inds1__]epsilonname[inds2__]:=SignDetOfMetric[metric]ExpandGdelta[Gdelta[inds1,inds2]]
];
If[$ProtectNewSymbols,Protect[epsilonname]]
];
]


MakeLinearMetric[metric_,invmetric_,newdelta_,vbundle_]:=With[
{vbQ=xAct`xTensor`Private`VBundleIndexQ[vbundle],firstQ=invmetric===metric
(*vbQ inserts a VBundleQ string that also checks Up-ness*)
},
If[!firstQ,(*G:is vbQ the total?*)
invmetric/:metric[-a_,-b_?vbQ]invmetric[b_?EIndexQ,c_]:=newdelta[-a,c] /;SubvbundleQ[vbundle,VBundleOfIndex[a]]&&SubvbundleQ[vbundle,VBundleOfIndex[c]];
invmetric/:metric[-b_?vbQ,-a_]invmetric[b_?EIndexQ,c_]:=newdelta[-a,c] /;SubvbundleQ[vbundle,VBundleOfIndex[a]]&&SubvbundleQ[vbundle,VBundleOfIndex[c]];
invmetric/:metric[-a_,-b_?vbQ]invmetric[c_,b_?EIndexQ]:=newdelta[-a,c] /;SubvbundleQ[vbundle,VBundleOfIndex[a]]&&SubvbundleQ[vbundle,VBundleOfIndex[c]];
invmetric/:metric[-b_?vbQ,-a_]invmetric[c_,b_?EIndexQ]:=newdelta[-a,c] /;SubvbundleQ[vbundle,VBundleOfIndex[a]]&&SubvbundleQ[vbundle,VBundleOfIndex[c]];
]
If[firstQ,
metric[a_?UpIndexQ,-b_]:=newdelta[-b,a] /;SubvbundleQ[vbundle,VBundleOfIndex[a]]&&SubvbundleQ[vbundle,VBundleOfIndex[b]];
metric[-a_,b_?UpIndexQ]:=newdelta[-a,b] /;SubvbundleQ[vbundle,VBundleOfIndex[a]]&&SubvbundleQ[vbundle,VBundleOfIndex[b]];
HoldPattern[metric[a_,b_?vbQ]metric[-b_?EIndexQ,c_]]^:=metric[a,c] /;SubvbundleQ[vbundle,VBundleOfIndex[a]]&&SubvbundleQ[vbundle,VBundleOfIndex[c]];
HoldPattern[metric[a_,b_?vbQ]metric[c_,-b_?EIndexQ]]^:=metric[a,c] /;SubvbundleQ[vbundle,VBundleOfIndex[a]]&&SubvbundleQ[vbundle,VBundleOfIndex[c]];
HoldPattern[metric[b_?vbQ,a_]metric[-b_?EIndexQ,c_]]^:=metric[a,c] /;SubvbundleQ[vbundle,VBundleOfIndex[a]]&&SubvbundleQ[vbundle,VBundleOfIndex[c]];
HoldPattern[metric[b_?vbQ,a_]metric[c_,-b_?EIndexQ]]^:=metric[a,c] /;SubvbundleQ[vbundle,VBundleOfIndex[a]]&&SubvbundleQ[vbundle,VBundleOfIndex[c]];
];
invmetric/:HoldPattern[der_?FirstDerQ[invmetric[b_?vbQ,c_?vbQ]]]:=Module[{b1=DummyIn[vbundle],c1=DummyIn[vbundle]},-invmetric[b,b1]invmetric[c,c1]der[metric[-b1,-c1]]];
]
MakeLinearMetric[metric_,newdelta_]:=MakeLinearMetric[metric,metric,newdelta,Replace[SlotsOfTensor[metric][[1]],-a_->a ],True]


MakeParallel[metric_[ind1_,ind2_],covd_]:=With[
{vQ1=And[SameBundleQ[ind1],SameUpDownQ[ind1]],
vQ2=And[SameBundleQ[ind2],SameUpDownQ[ind2]]},
covd[c_][metric[a_?vQ1,b_?vQ2]]^=0;
(*TensorDerivative[metric,covd,___]:=Zero;
MetricOfCovD[covd]^=metric;
metric/:CovDOfMetric[metric]=covd;*)
]


functions={TraceProductDummy};
Unprotect@@functions;
Map[SetDelayed[#[equality_Equal],#/@equality]&,functions];
Protect@@functions;
Clear[functions];
(*FoldOut[]
Do[Print[function]
Unprotect[function]
function[equality_Equal]:=function/@equality
Protect[function],{function,{TraceProductDummy}}];*)



EqTimes[exp_][exp2_Equal]:=Map[ exp*#&,exp2];
EqChangeFreeIndices[free_List][exp_Equal]:=Map[ChangeFreeIndices[#,free]&,exp];
EqTraceProductDummy[exp_Equal]:=Map[TraceProductDummy,exp];
EqIndices[exp_Equal]:=HoldFirst[Map[{FindFreeIndices[#],FindDummyIndices[#]}&,exp]]


ProjectOnto[inds__][exp_]:=ReplaceIndex[exp,
Inner[Rule,List@@IndicesOf[Free][exp],List[inds],List]]/;
Length[IndicesOf[Free][exp]]==Length[List[inds]]


EndPackage[]
